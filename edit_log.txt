I decided to type my notes because it may be easier to follow.

================================================================================

>>> 12/07

The following functions were not defined in any of the .c files, although they appear in decs.h

    void push_photon_ham(double X[NDIM], double Kcon[][NDIM], double dl[]);
    void push_photon_cart(double X[NDIM], double Kcon[NDIM], double dKcon[NDIM], double dl);
    void push_photon_gsl(double X[NDIM], double Kcon[NDIM], double dl);
    int geodesic_deriv(double t, const double y[], double dy[], void *params);
    void interpolate_geodesic(double Xi[], double X[], double Ki[], double K[], double frac, double del_l);

I think these functions provide integration methods (push_photon_*).
geodesic_deriv probably derives/solves(?) the geodesic equation
interpolate_geodesic seems obvious from the definition

--------------------------------------------------------------------------------

It seems that the following files don't need any edits for 3D adaptation:

    compton.c          -- almost certain (unsure about v1* and v2* quantities)
    constants.h        -- certain
    geodesics.c        -- almost certain
    grmonty.c          -- certain
    hotcross.c         -- almost certain
    init_geometry.c    -- certain
    jnu_mixed.c        -- certain
    radiation.c        -- certain
    tetrads.c          -- certain

The following files need edits for 3D adaptation:

    decs.h
    harm_model.c
    harm_model.h
    harm_utils.c
    init_harm_data.c
    scatter_super_photon.c
    track_super_photon.c

--------------------------------------------------------------------------------

ABSOLUTELY VITAL: Must understand what is geom[][], because this appears in a lot of places and may require modification

Must do this BEFORE modifying the files!

update: geom very likely to need extra []

May have to add extra * to variables in harm_model.h

    global double ****econ;
    global double ****ecov;
    global double ***bcon;
    global double ***bcov;
    global double ***ucon;
    global double ***ucov;
    global double ***p;
    global double **ne;
    global double **thetae;
    global double **b;

I think bcon to thetae will need extra * - b and u will not
b likely to remain the same - NO
Unsure about econ and ecov

--------------------------------------------------------------------------------

decs.h

//    line 97-98: modify struct of_photon to include X3i ?


harm_model.h

//    line 63: add *phi
//    lines 72-77: add int k
//    line 75: change Xtoij to Xtoijk


init_harm_data.c

//    line 63: add phip
//    line 69: add phi (or whatever we may call it)
    lines 81-107: change HARM header to account for phi-dimension (add N3, startx[3] and dx[3]) and make sure variables match with dump file generated. If not, add variables as required
//    line 111: likely remove startx[3] = 0.
//    line 116: likely change stopx[3] so that it resembles stopx[1] and stopx[2]
//    line 118: also print startx[3] and stopx[3]
//    line 122: likely remove dx[3] = 2. * M_PI
//    lines 137-139: likely unchanged but must make sure  -- note added: changed and didn't comment
//    line 140: add %f, X[3], &phi (or whatever we may call it)
//    lines 143-147: add phip (or whatever we may call it) -- added stuff, but we must understand what condition to add too
//    lines 153-159, 179, 185, 187: add [k] to p  -- note added: didn't comment
    lines 140-176: add whatever new variables may be necessary to fscanf

(when modifying init_harm_data.c, check Sasha's tutorial for harmpi and check dump019 to make sure about variables)


harm_utils.c

//    line 58: change Xtoij to Xtoijk, add int *k
//    line 59: add int k
//    line 60: add int k
//    lines 71-82: add k?, var...[k]? plus lots of coefficients and var[][][] (basically account for new dimension)
//    line 122: add int k
//    line 142: add k
//    line 152-153: add k loop -- note added: didn't comment
//    line 153: add k in get_fluid_zone, add k in geom  -- note added: didn't comment
//    line 221: add int k
//    line 229: add k in get_fluid_zone
//    line 284: geom...[k]?
//    line 287: add %d
//    line 288: add k
//    line 297: add int *k
//    lines 305-306: add static int zk = ?
//    lines 307-317: add k loop?  -- note added: didn't comment
//    line 318: add zk
//    line 327: add *k = zk
//    line 331: add int k
//    line 341: add k
//    line 345: add k
//    line 383: geom...[k]?
//    lines 397-398: add X3i, X[3]
//    line 406: change Xtoij to Xtoijk, add int *k
//    lines 410-411: add *k
//    lines 430-431: add loop for *k
//    lines 436-443: add *phi (or whatever it is called) to bl_coord?
//    line 445: add int k
//    line 452: make X[3] like X[1], X[2]
//    line 497: add int k to init_geometry
//    lines 500-502: add k loop -- note added: didn't comment
//    line 504: add k to coord -- note added: didn't comment
//    lines 506-510: add [k] to geom? -- note added: didn't comment


harm_model.c

//    line 102: add zone_k
//    line 108: add &zone_k
//    line 120: add zone_k
//    line 152: add int k
//    lines 160-169: add [k] to p -- note added: didn't comment
//    lines 175-189: add [k] to geom? -- note added: didn't comment
//    line 201: add int k
//    line 206: add int k
//    lines 208, 209: add startx[3], stopx[3], X[3] -- note added: didn't comment
//    line 216: change Xtoij to Xtoijk, add &k
//    lines 218-221: add lots of coeff to account for extra dimension, add del[3]
//    lines 223-224: add k
//    lines 229-235: add k  -- note added: didn't comment
//    line 239: add loop for k? -- note added: not necessary
//    line 281: add double phi (or whatever it is called)
//    line 288: add &phi (or whatever it is called) to bl_coord?
//    line 316: add double phi (or whatever it is called)
//    line 323: add &phi (or whatever it is called) to bl_coord?
//    line 387: account for 3d - may need to change christoffel symbols
//    lines 595-597: change anything in line 597? if so, probably like dlx2 -- note added: still unsure, but modified anyway
//    lines 660-662: change anything in line 662? -- note added: still unsure, but modified anyway


scatter_super_photon.c

//    lines 70-79: add X[3] in line 77
//    lines 168-169: add new line with X3i


track_super_photon.c

//    lines 295-301: add X[3], K[3]


================================================================================

>>> 13/07

Created a branch called 3dtests as a damage control if I fuck things up :) -- note added 14/07: moved things to nemmen/grmonty; no longer working on this branch in my repository. Current working branch also called 3dtests

/***************************
On this new branch, I added the edits listed above for the following files:

    scatter_super_photon.c
    track_super_photon.c
    decs.h
***************************/

I'm adding to the list of edits done yesterday a c comment command for the edits I have already made.

--------------------------------------------------------------------------------

Variable coeff[4] must be rewritten to coeff[8]

--------------------------------------------------------------------------------

Only "non-trivial" modifications left. Tomorrow likely to be tiring, but good chance to finish this. Must not forget to bring laptop


================================================================================

>>> 14/07


Variable del[NDIM] to remain defined as is, but must add del[3] so we can define the other coeff[] elements.

Variable coeff[4] to be changed to account for 4 extra elements: coeff[8], because now we have del[3] - NOTE ADDED: MAY BE WRONG! GET THIS RIGHT!

--------------------------------------------------------------------------------

Understand the following variables:

    n2gen
    in2gen

Understand the following functions:

    get_zone (utils)
    init_zone (utils)
    get_fluid_zone (model)

--------------------------------------------------------------------------------

Add printf to understand the change in zi, zj (2d version) so we can understand the algorithm in get_zone

printf("%f %f\n", zi, zj)

ADDED: done, I think I got it right, but must add print to 3d version to make sure. - DONE RIGHT

--------------------------------------------------------------------------------

I think we don't have to change harm_model.c line 387 - must test, though.

--------------------------------------------------------------------------------

Points that may be troublesome:

    line 387- (see above)
    zk (definition of get_zone in harm_utils.c)
    loop for k to get the data (init_harm_data.c)

--------------------------------------------------------------------------------

Next things to do - hopefully the last as well:

    1) write c function to convert from binary to ascii
    2) run harmpi with 3d
    3) check harm_model.h variables (extra * needed?)

--------------------------------------------------------------------------------

Just realized I have to change the malloc functions in the end of harm_utils.c

================================================================================

>>> 21/08

Some things I noticed and some random thoughts. To be properly organized on the next note.

When I run the unmodified version, in 'harm_utils.c', function 'get_zone', I set it to print "if" or "else" in the 'if-else' loop. It prints either "if" or "else", as expected, but in the 3d version it only prints "else". I noticed that 'n2gen' has taken the values 0, 1 and 2 in the unmodified 2d version, while it takes only 0 in the 3d version.

I remember that the Illinois version was bugged, but I don't know if this is related to the dump files - it may simply be different.

Also, I am noticing that the values from the converted-from-binary dump files are very strange. There is probably something very wrong in the conversion functions that we have been writing and I am strongly considering writing a Python script like Sasha's, which seems to be correct, so as to avoid all this headache.

But I think Rodrigo once told me that one C script to convert the binary data resulted in values that were in accordance with Sasha's Python script.

Another thing I may do is remove the Illinois modifications from the branch harmpi_gustavo and go back to the "original".

0) write Python script to handle the binary-to-ascii conversion. Test. --- EDIT: seems promising
1) comment out Illinois modifications and go back to the original version. Then test.
2a) If it runs, the problem is in the Illinois modification.
2b) If it doesn't run, the problem is somewhere else.

In 'init_harm_data.c', add MINIMUM modifications. Namely: only change the variables to be read so that they are in accordance with dump files, and add whatever new variables to declarations. ADD NOTHING ELSE.

--------------------------------------------------------------------------------

Since the Python script seems to be promising, I think I have settled on a strategy to work this out:

1) Write Python script to transform binary data to ascii. - in progress OK
2) Create 'init_harm_data_gustavo.c' with MINIMUM modifications: add variables only as needed and DO NOT CHANGE the structure OK
3) Generate data using Python script OK
4) Compile code with 'init_harm_data_gustavo.c' OK
5) Run using file generated by Python OK
6) See what happens - SEGMENTATION FAULT :(

If it is still bugged, at least we will know the problem is no longer (if it ever was before) the data. Then, we are going to need to recheck the modifications made.

===============================================================================

29/08

PROBLEM FOUND!

In make_super_photon (harm_model.c), we never get out of the while(n2gen <= 0) loop until we reach the last i-zone (zone_i == N1), because once we get there n2gen is forced to be 1. This is not the case in the 2d version, where we occasionally leave this loop and return later. Since we only get out of the loop when we reach the last i-zone, this will trigger a change in *quit_flag from 0 to 1. This, in turn, makes the program skip the loop to sample photons, which explains why the program does not generate any photons. 

The reason why we never leave the while(n2gen <= 0) loop until we reach the last i-zone is actually simple, but requires a long explanation. In the function get_zone (harm_utils.c), there is an if-else loop that returns the value of in2gen. After adding some control printf to try to pinpoint possible issues, I found that only the "else" part is called, meaning that the if-condition is never met. Also, I noticed that in2gen was ALWAYS equal to zero, while in the 2d version this wasn't always the case. In the 2d version, the "if" part was occasionally called.

The if-condition states that the remainder of the division n2gen/1. has to be greater than some random number. I checked this random number generator and there was nothing wrong with it. I had previously checked the control loop (zi, zj, zk) that appears before that, and found no issues with that. Therefore, the error had to be related to n2gen in the init_zone (harm_utils.c) function called immediately before the if-else loop, since n2gen is one of the arguments taken by this function.

Upon inspecting the function init_zone (harm_utils.c), I noticed that there are many if-conditions that, if satisfied, will force n2gen (here called *nz) to take the value of zero. Since the remainder of the division of 0 by 1. is 0, I figured that this could be the problem: we were satisfying some condition that automatically sets the value of *nz to zero every time init_zone (harm_utils.c) was called. Since it was called by get_zone (harm_utils.c), which is the only function inside the while(n2gen <= 0) loop in make_super_photon, this was the reason why we would never leave this loop until we reached the last i-zone.

Now, the very first if-condition in init_zone (harm_utils.c) was inspected and after telling the program to print the values of Ne, Thetae and THETAE_MIN, I found that Thetae was always either -0.000000 or 0.000000, smaller than THETAE_MIN and therefore satisfying this if-condition. This is why n2gen is always zero until we reach the last i-zone.

Inspecting the function get_fluid_zone (harm_model.c), which is called by init_zone (harm_utils.c), we see that *Thetae is assigned a value related to p[UU][i][j][k], which is a value we read from the data in init_harm_data.c. When printing the value of this variable, we always get either -0.000000 or 0.000000, explaining the value of Thetae.

Therefore, the data being read is possibly wrong (maybe due to some error in the routines to transform from binary to ascii), and this is the source of the problems we have been facing in the last couple of days.

===============================================================================

13/12

Created branch "3dmosc" to reproduce MoÅ›cibrodzka, Falcke 2013

In branch 3dmosc, changed the following files:

decs.h

    added constants:
        TP_OVER_TE_JET
        TP_OVER_TE_DISK
        BETA_LORENTZ_MIN

    removed constant:
        TP_OVER_TE


init_harm_data_gustavo.c

    added variables:
        beta_lorentz
        tp_over_te

    changed Thetae_unit to Thetae_unit[i][j][k]
    moved calculation of two_temp_gam and Thetae_unit[i][j][k] to loop
    commented out previous calculation


harm_utils.c
    
    added variable:
        extern double ***Thetae_unit


harm_model.c
    
    changed line:
        *Thetae = p[UU][i][j][k] / (*Ne) * Ne_unit * Thetae_unit[i][j][k];
